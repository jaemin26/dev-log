### 적용 범위

- **PO (Purchase Order)**: 발주 모듈
- **GR (Goods Receipt)**: 입고 모듈

---

## Backend 변경사항

### 1. PurchaseOrderController.java - 권한 어노테이션 적용

**파일 경로**: `src/main/java/com/company/erp/po/controller/PurchaseOrderController.java`

### 변경 전

```java
@RestController
@RequestMapping("/api/v1/purchase-orders")
@RequiredArgsConstructor
public class PurchaseOrderController {
```

### 변경 후

```java
import com.company.erp.common.auth.RequireRole;

@RestController
@RequestMapping("/api/v1/purchase-orders")
@RequiredArgsConstructor
@RequireRole({"BUYER", "ADMIN"})  // 클래스 레벨 기본: 구매팀/관리자만 접근
public class PurchaseOrderController {
```

> [!NOTE]
클래스 레벨에 @RequireRole을 적용하면 모든 메서드에 기본 적용됩니다.
특정 메서드만 다른 권한이 필요하면 메서드 레벨에서 오버라이드합니다.
> 

---

### 상세 조회 - VENDOR 접근 허용

**변경 전**

```java
// 상세 조회
@GetMapping("/{no}")
public ResponseEntity<PurchaseOrderDTO> getDetail(@PathVariable String no) {
```

**변경 후**

```java
// 상세 조회 - VENDOR도 본인 발주 조회 가능 (Service에서 검증)
@RequireRole({"BUYER", "VENDOR", "ADMIN"})
@GetMapping("/{no}")
public ResponseEntity<PurchaseOrderDTO> getDetail(@PathVariable String no) {
```

---

### 협력사 수신확인 - VENDOR 전용

**변경 전**

```java
// 협력사 수신확인
@PutMapping("/{no}/vendor-confirm")
public ResponseEntity<Void> vendorConfirm(@PathVariable String no) {
```

**변경 후**

```java
// 협력사 수신확인 - VENDOR 전용
@RequireRole({"VENDOR"})
@PutMapping("/{no}/vendor-confirm")
public ResponseEntity<Void> vendorConfirm(@PathVariable String no) {
```

---

### 신규 엔드포인트 - 협력사 전용 발주 목록 조회

**추가된 코드**

```java
// ========== 협력사 전용: 본인 발주 목록 조회 ==========
@RequireRole({"VENDOR"})
@GetMapping("/vendor/orders")
public ResponseEntity<List<PurchaseOrderDTO>> getVendorOrderList(
        @RequestParam(required = false) String poNo,
        @RequestParam(required = false) String poName,
        @RequestParam(required = false) String status
) {
    List<PurchaseOrderDTO> list = purchaseOrderService.getVendorOrderList(poNo, poName, status);
    return ResponseEntity.ok(list);
}
```

기존 getList() API는 BUYER 전용이므로, VENDOR를 위한 별도 엔드포인트를 추가했습니다.
Service에서 세션의 vendorCd를 자동으로 필터에 추가했습니다.

---

### 2. GoodsReceiptController.java - 입고 모듈 권한 적용

**파일 경로**: `src/main/java/com/company/erp/inventory/controller/GoodsReceiptController.java`

### 변경 전

```java
@RestController
@RequestMapping("/api/v1/goods-receipts")
@RequiredArgsConstructor
public class GoodsReceiptController {
```

### 변경 후

```java
import com.company.erp.common.auth.RequireRole;

@RestController
@RequestMapping("/api/v1/goods-receipts")
@RequiredArgsConstructor
@RequireRole({"BUYER", "ADMIN"})  // 입고 모듈: 구매팀/관리자만 접근 가능
public class GoodsReceiptController {
```

입고 모듈은 협력사가 접근할 기능이 없으므로 클래스 레벨에서 BUYER, ADMIN만 허용합니다.

---

### 3. PurchaseOrderService.java - VENDOR 데이터 제한

**파일 경로**: `src/main/java/com/company/erp/po/service/PurchaseOrderService.java`

### getDetail() - 본인 협력사 발주만 조회

**변경 전**

```java
public PurchaseOrderDTO getDetail(String poNo) {
    PurchaseOrderDTO header = purchaseOrderMapper.selectHeader(poNo);
    if (header == null) {
        throw new NoSuchElementException("발주를 찾을 수 없습니다: " + poNo);
    }

    List<PurchaseOrderItemDTO> items = purchaseOrderMapper.selectItems(poNo);
    header.setItems(items);

    return header;
}
```

**변경 후**

```java
public PurchaseOrderDTO getDetail(String poNo) {
    PurchaseOrderDTO header = purchaseOrderMapper.selectHeader(poNo);
    if (header == null) {
        throw new NoSuchElementException("발주를 찾을 수 없습니다: " + poNo);
    }

    // VENDOR인 경우: 본인 협력사 발주만 조회 가능
    SessionUser user = getSessionUser();
    if (user != null && "VENDOR".equals(user.getRole())) {
        String userVendorCd = user.getVendorCd();
        if (userVendorCd == null || !userVendorCd.equals(header.getVendorCode())) {
            throw new SecurityException("본인 협력사의 발주만 조회할 수 있습니다.");
        }
    }

    List<PurchaseOrderItemDTO> items = purchaseOrderMapper.selectItems(poNo);
    header.setItems(items);

    return header;
}
```

**Controller의 @RequireRole만으로는 “본인 데이터” 검증이 불가능합니다.
Service 레이어에서 세션의 vendorCd와 발주의 VENDOR_CD를 비교해야 합니다.**

---

### vendorConfirm() - 본인 협력사 발주만 수신확인

**추가된 검증 로직**

```java
public Boolean vendorConfirm(String poNo) {
    PurchaseOrderDTO existing = purchaseOrderMapper.selectHeader(poNo);
    if (existing == null) {
        throw new NoSuchElementException("발주를 찾을 수 없습니다: " + poNo);
    }

    // VENDOR 본인 협력사 발주만 수신확인 가능
    SessionUser user = getSessionUser();
    if (user != null && "VENDOR".equals(user.getRole())) {
        String userVendorCd = user.getVendorCd();
        if (userVendorCd == null || !userVendorCd.equals(existing.getVendorCode())) {
            throw new SecurityException("본인 협력사의 발주만 수신확인할 수 있습니다.");
        }
    }

    // ... 이하 기존 로직
}
```

---

### 신규 메서드 - getVendorOrderList()

**추가된 코드**

```java
// 협력사 전용: 본인 발주 목록 조회
public List<PurchaseOrderDTO> getVendorOrderList(String poNo, String poName, String status) {
    SessionUser user = getSessionUser();
    if (user == null || user.getVendorCd() == null) {
        throw new SecurityException("협력사 정보가 없습니다.");
    }

    Map<String, Object> params = new HashMap<>();
    params.put("poNo", poNo);
    params.put("poName", poName);
    params.put("status", status);
    params.put("vendorCd", user.getVendorCd()); // 본인 협력사 발주만 조회

    List<PurchaseOrderDTO> list = purchaseOrderMapper.selectVendorOrderList(params);

    // 각 PO에 대해 품목 상세 조회하여 추가
    for (PurchaseOrderDTO po : list) {
        if (po.getPoNo() != null) {
            List<PurchaseOrderItemDTO> items = purchaseOrderMapper.selectItems(po.getPoNo());
            po.setItems(items);
        }
    }

    return list;
}
```

---

### 4. PurchaseOrderMapper.java - 인터페이스 추가

**파일 경로**: `src/main/java/com/company/erp/po/mapper/PurchaseOrderMapper.java`

**추가된 코드**

```java
// 협력사 전용: 본인 발주 목록 조회
List<PurchaseOrderDTO> selectVendorOrderList(Map<String, Object> params);
```

---

### 5. PurchaseOrderMapper.xml - SQL 추가

**파일 경로**: `src/main/resources/mapper/po/PurchaseOrderMapper.xml`

**추가된 SQL**

```xml
<!-- 협력사 전용: 본인 발주 목록 조회 -->
<select id="selectVendorOrderList" parameterType="map"
        resultType="com.company.erp.po.dto.PurchaseOrderDTO">
    SELECT h.PO_NUM AS poNo, h.PO_SUBJECT AS poName, h.PO_DATE AS poDate,
           h.PO_AMT AS totalAmount, h.PROGRESS_CD AS status,
           h.CTRL_USER_ID AS purchaseManager, h.VENDOR_CD AS vendorCode,
           v.VENDOR_NM AS vendorName, h.PR_NUM AS prNo, h.RFQ_NUM AS rfqNo,
           h.PC_TYPE AS purchaseType, h.CHECK_FLAG AS checkFlag,
           h.CHECK_DATE AS checkDate, h.RMK AS remark
    FROM POHD h
    LEFT JOIN VNGL v ON h.VENDOR_CD = v.VENDOR_CD
    WHERE h.DEL_FLAG = 'N'
    AND h.VENDOR_CD = #{vendorCd}  <!-- 필수 조건: 본인 협력사만 -->
    <if test="poNo != null and poNo != ''">
        AND h.PO_NUM LIKE CONCAT('%', #{poNo}, '%')
    </if>
    <if test="poName != null and poName != ''">
        AND h.PO_SUBJECT LIKE CONCAT('%', #{poName}, '%')
    </if>
    <if test="status != null and status != ''">
        AND h.PROGRESS_CD = #{status}
    </if>
    ORDER BY h.REG_DATE DESC
</select>
```

vendorCd는 필수 파라미터로, WHERE 절에서 항상 적용
이를 통해 협력사는 자신의 발주만 조회할 수 있습니다.

---

### 3. API 엔드포인트 변경

**변경 전**

```tsx
// 발주전송(S) 상태만 조회
const response = await fetch("/api/v1/purchase-orders?status=S");
```

**변경 후**

```tsx
// 협력사 전용 API 사용 (자동으로 본인 협력사 발주만 조회)
const response = await fetch("/api/v1/purchase-orders/vendor/orders?status=S");
```