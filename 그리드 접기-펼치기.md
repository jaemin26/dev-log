**예시) frontend/src/app/(main)/order/pending/page.tsx**

## ✨수정 내용

발주 대기 목록을 **RFQ 단위로 그룹화**하여 표시하고, 각 RFQ 행을 클릭하면 품목 상세가 펼쳐지는 방식으로 개선.

### **1. RFQ 그룹화 구조**

**Before**: 품목별로 개별 행 표시

```tsx
RFQ-2026-0006 | ... | ITM20250011 | A4 용지 | ...
RFQ-2026-0006 | ... | ITM20250012 | 볼펜 | ...
RFQ-2026-0006 | ... | ITM20250013 | 포스트잇 | ...

```

**After**: RFQ별로 1개 행, 클릭 시 품목 펼침

```tsx
▶ ☐ RFQ-2026-0006 | 견적명 | ... | 3개 | ₩585,000

```

클릭 후:

```tsx
▼ ☑ RFQ-2026-0006 | 견적명 | ... | 3개 | ₩585,000
    ├─ ITM20250011 | A4 용지 | 50개 | ₩225,000
    ├─ ITM20250012 | 볼펜 | 20개 | ₩160,000
    └─ ITM20250013 | 포스트잇 | 30개 | ₩360,000

```

### **2. 새로운 인터페이스**

```tsx
interfaceRfqGroup{
rfqNo:string;
rfqName:string;
purchaseType:string;
purchaseTypeDisplay:string;
buyer:string;
rfqDate:string;
vendorCode:string;
vendorName:string;
itemCount:number;// 품목 개수
totalAmount:number;// 총 금액
items:RfqSelectedItemDTO[];// 품목 목록
}

```

### **3. 상태 관리**

```tsx
// 펼쳐진 RFQ 추적
const[expandedRfqs,setExpandedRfqs]=useState<Set<string>>(newSet());

// 선택된 RFQ (1개만 선택 가능)
const[selectedRfqNo,setSelectedRfqNo]=useState<string|null>(null);

// 펼치기/접기 토글
consttoggleExpand=(rfqNo:string)=>{
constnewExpanded=newSet(expandedRfqs);
if (newExpanded.has(rfqNo)) {
newExpanded.delete(rfqNo);
  }else {
newExpanded.add(rfqNo);
  }
setExpandedRfqs(newExpanded);
};

```

### **사용자 인터랙션**

### **펼치기/접기**

```tsx
// 행의 대부분 영역 클릭 시 펼침/접힘
onClick={() =>toggleExpand(group.rfqNo)}

// 체크박스는 선택 동작만 수행
onClick={(e) => e.stopPropagation()}

```

- 체크박스 클릭 시 해당 RFQ 선택
- 한 번에 1개 RFQ만 선택 가능
- 선택된 RFQ는 청록색 배경으로 강조

### **발주서 작성**

- 선택된 RFQ의 모든 품목이 자동으로 발주 모달에 포함
- RFQ 번호가 자동으로 발주 데이터에 포함됨

---

## **기술 세부사항**

### **데이터 변환**

```tsx
// API 응답을 RFQ 그룹으로 변환
constgroups:RfqGroup[]=result.map((rfq:RfqSelectedDTO)=>{
consttotalAmount=rfq.items?.reduce(
    (sum,item)=>sum+ (Number(item.amount)||0),
0
  )||0;

return {
rfqNo:rfq.rfqNo||'',
// ... 기타 필드
itemCount:rfq.items?.length||0,
totalAmount,
items:rfq.items|| [],
  };
});

```

### **조건부 렌더링**

```tsx
{expandedRfqs.has(group.rfqNo)&& (
<tr>
<tdcolSpan={10}className="bg-stone-50/50 px-4 py-3">
      {/* 품목 상세 테이블 */}
</td>
</tr>
)}

```

### **CSS 애니메이션**

```tsx
className={`
  w-5 h-5 text-stone-400
  transition-transform duration-200
${expandedRfqs.has(group.rfqNo)?'rotate-90':''}
`}

```

## React hooks

# **useState Hook 설명**

`useState`는 React의 가장 기본적이고 중요한 Hook. 함수형 컴포넌트에서 **상태(state)** 를 관리할 수 있게 해줍니다.

## **기본 문법**

```tsx
const[상태값,상태변경함수]=useState(초기값);

```

## **실제 예시 (지금 구현한 코드에서)**

### **1. 단순 값 저장**

```tsx
// 로딩 상태 관리
const[loading,setLoading]=useState(false);

// 사용
setLoading(true);// 로딩 시작
setLoading(false);// 로딩 종료

```

### **2. 문자열 저장**

```tsx
// 선택된 RFQ 번호 저장
const[selectedRfqNo,setSelectedRfqNo]=useState<string|null>(null);

// 사용
setSelectedRfqNo('RFQ-2026-0006');// RFQ 선택
setSelectedRfqNo(null);// 선택 해제

```

### **3. Set 객체 저장**

```tsx
// 펼쳐진 RFQ 목록 저장
const[expandedRfqs,setExpandedRfqs]=useState<Set<string>>(newSet());

// 사용
constnewExpanded=newSet(expandedRfqs);
newExpanded.add('RFQ-2026-0006');// RFQ 펼치기
setExpandedRfqs(newExpanded);

```

### **4. 배열 저장**

```tsx
// RFQ 그룹 목록 저장
const[rfqGroups,setRfqGroups]=useState<RfqGroup[]>([]);

// 사용
setRfqGroups([group1,group2,group3]);

```

### **5. 객체 저장**

```tsx
// 검색 파라미터 저장
const[searchParams,setSearchParams]=useState({
rfqNo:'',
rfqName:'',
vendorName:'',
});

// 사용 - 특정 필드만 업데이트
setSearchParams(prev=>({
...prev,// 기존 값 유지
rfqNo:'RFQ-001'// rfqNo만 변경
}));

```

## **핵심 개념**

### **1. 상태가 변경되면 컴포넌트가 다시 렌더링됨**

```tsx
const[count,setCount]=useState(0);

// 버튼 클릭 시
setCount(count+1);// count가 1 증가하고, 화면이 자동으로 업데이트됨!

```

### **2. 이전 값을 기반으로 업데이트**

```tsx
// ❌ 잘못된 방법 (동시에 여러 번 호출 시 문제)
setCount(count+1);
setCount(count+1);// 여전히 1만 증가

// ✅ 올바른 방법
setCount(prev=>prev+1);
setCount(prev=>prev+1);// 2 증가

```

### **3. 객체/배열 업데이트 시 불변성 유지**

```tsx
// ❌ 잘못된 방법 (원본 수정)
searchParams.rfqNo='RFQ-001';
setSearchParams(searchParams);// React가 변경을 감지 못함!

// ✅ 올바른 방법 (새 객체 생성)
setSearchParams({...searchParams,rfqNo:'RFQ-001'});

```

## **실전 활용 예시**

### **펼치기/접기 토글**

```tsx
const[expandedRfqs,setExpandedRfqs]=useState<Set<string>>(newSet());

consttoggleExpand=(rfqNo:string)=>{
constnewExpanded=newSet(expandedRfqs);// 1. 복사본 생성

if (newExpanded.has(rfqNo)) {
newExpanded.delete(rfqNo);// 2. 이미 있으면 제거
  }else {
newExpanded.add(rfqNo);// 3. 없으면 추가
  }

setExpandedRfqs(newExpanded);// 4. 상태 업데이트 → 화면 자동 갱신!
};

```

### **폼 입력 관리**

```tsx
const[orderForm,setOrderForm]=useState({
poName:'',
poDate:'',
items:[],
});

// 특정 필드만 업데이트
<Input
value={orderForm.poName}
onChange={(e) =>setOrderForm(prev=>({
...prev,
poName:e.target.value// poName만 변경, 나머지는 유지
}))}
/>

```

## **왜 useState를 사용하나요?**

### **일반 변수와의 차이**

```tsx
// ❌ 일반 변수 - 변경해도 화면이 안 바뀜!
letcount=0;
count=count+1;// 값은 바뀌지만 화면은 그대로

// ✅ useState - 변경하면 화면이 자동으로 바뀜!
const[count,setCount]=useState(0);
setCount(count+1);// 값도 바뀌고 화면도 자동 갱신!

```

## **요약**

| **항목** | **설명** |
| --- | --- |
| **목적** | 컴포넌트의 상태를 저장하고 관리 |
| **반환값** | `[현재값, 변경함수]` 배열 |
| **특징** | 상태 변경 시 자동으로 화면 재렌더링 |
| **주의사항** | 객체/배열은 새로운 것을 만들어서 전달 (불변성) |

## **동작 흐름**

```
1. 사용자가 RFQ 행 클릭
   ↓
2. toggleExpand('RFQ-2026-0006') 호출
   ↓
3. expandedRfqs에 'RFQ-2026-0006' 추가
   ↓
4. setExpandedRfqs(newExpanded) 실행
   ↓
5. React가 "상태가 바뀌었네!" 감지
   ↓
6. 컴포넌트 다시 렌더링
   ↓
7. expandedRfqs.has('RFQ-2026-0006') === true
   ↓
8. 화살표 90도 회전 + 품목 상세 테이블 표시!

```