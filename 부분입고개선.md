### **현재 문제점**

```
발주수량: 100개
1차 입고: 30개 (부분입고)
2차 입고 시: 100개로 표시됨 ❌

원하는 동작:
2차 입고 시: 70개로 표시되어야 함 ✅ (100 - 30)

```

### **백엔드에서 처리해야 하는 이유**

1. **데이터 정합성**: 입고 이력은 DB에 저장되어 있음
2. **계산 로직**: 발주수량 - 이미 입고된 수량 = 남은 수량
3. **여러 입고 건**: 부분 입고가 여러 번 발생할 수 있음

## **수정**

### **1. 백엔드 수정**

**GoodsReceiptService.java**에서 각 품목의 **남은 입고 수량**을 계산해서 반환:

```java
// 각 PO에 대해 품목 상세 조회하여 추가
for (PurchaseOrderDTO po : list) {
    if (po.getPoNo() != null) {
        List<PurchaseOrderItemDTO> items = purchaseOrderMapper.selectItems(po.getPoNo());
        
        // 각 품목별로 이미 입고된 수량 조회
        for (PurchaseOrderItemDTO item : items) {
            // 이미 입고된 수량 조회
            Integer receivedQty = goodsReceiptMapper.getReceivedQuantity(
                po.getPoNo(), 
                item.getItemCode()
            );
            
            // 남은 수량 계산
            int remainingQty = item.getOrderQuantity() - (receivedQty != null ? receivedQty : 0);
            
            // 남은 수량을 orderQuantity에 설정 (또는 새 필드 추가)
            item.setOrderQuantity(remainingQty);
            // 또는
            item.setRemainingQuantity(remainingQty); // DTO에 필드 추가 필요
        }
        
        po.setItems(items);
    }
}
```

### **2. 필요한 Mapper 메서드 추가**

**GoodsReceiptMapper.xml**에 쿼리 추가:

```sql
<!-- 특정 PO의 품목별 입고된 총 수량 조회 -->
<selectid="getReceivedQuantity"resultType="java.lang.Integer">
    SELECT COALESCE(SUM(GR_QT), 0)
    FROM GRDT
    WHERE GR_NUM IN (
        SELECT GR_NUM
        FROM GRHD
        WHERE PO_NUM = #{poNo}
          AND DEL_FLAG = 'N'
          AND PROGRESS_CD != 'GRX'  -- 입고취소 제외
    )
    AND ITEM_CD = #{itemCode}
    AND DEL_FLAG = 'N'
</select>

```

### **3. DTO 수정**

**PurchaseOrderItemDTO.java**에 필드 추가:

```java
privateIntegerremainingQuantity;// 남은 입고 가능 수량

```

이제 서버에서 `발주수량 - 이미 입고된 수량`을 계산하여 `남은 수량(remainingQuantity)`을 정확하게 보냄.